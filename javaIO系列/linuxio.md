# Linux I/O



## 前置知识

参考：[理解linux中的file descriptor(文件描述符) | Bigbyto (wiyi.org)](https://wiyi.org/linux-file-descriptor.html#操作file-descriptors)

### 文件描述符

和fd相关的有三张表：

- file descriptor ：记录了进程打开的所有文件代表的fd
- file table：全局的表（记录文件状态），由内核维护
- inode table：全局表，记录了文件实际的地址



java中封装了fd；类名为FileDescriptor



### 内核

一堆等着cpu在特权级别下调用的代码



## 一次经典的阻塞型I/O

不谈



## 阻塞型

- 系统调用
- 进入内核态
- 线程阻塞，保留现场
- 内核方法阻塞式地等待数据准备好
- 内核方法此时可以被内核抢占
- 内核读取到数据后返回
- 切换到用户态
- 用户线程继续执行



## 非阻塞型

- 多次调用系统调用进行探测（非阻塞）
- 如果某次探测返回true
- 使用阻塞式的系统调用读取数据（现在数据应该准备好了）



## 复用型

- 将fd和事件注册起来，而不是直接调用读取数据的系统调用
- 阻塞select方法
- 如果有事件，则轮询事件读取数据
- 读取到数据后执行后续逻辑



## 异步型

- 用户线程执行aio_read后继续执行
- 内核负责将数据读取到并写到用户区
- 调用回调函数





## 以上三种io方式的比较

**阻塞与非阻塞：**

体现的是用户线程等待数据的方式。有阻塞方式，也有轮询方式。

**同步和异步：**

同步的方式指，除非数据读取到，否则用户线程不能继续执行；

异步的方式，就算数据没有读取到，用户线程也能够继续执行。













