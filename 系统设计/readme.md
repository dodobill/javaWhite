# 分布式





# 高性能





# 高可用





# 设计秒杀系统-1

参考这篇：[《我们一起进大厂》系列-秒杀系统设计 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903999083151374#heading-2)



## 秒杀系统要解决的问题

- 高并发==注意是并发，大量请求在短时间内陆续到达==
- 超卖
- 恶意请求

防黄牛

- 链接暴露

防止提前请求，又或者是脚本的毫秒级抢购。

- 数据库

防止数据库挂了，将不同业务的库分开，互不影响





## 设计

### 服务单一原则

- 微服务

秒杀服务挂了不影响其他业务

- 分库

秒杀库挂了，不影响其他数据库业务



### 针对秒杀链加盐

动态URL



### redis集群



### Nginx负载均衡

除了负载均衡还要考虑单个用户访问过快的问题。

可以基于ip限制并发数。



### 按钮控制



### 限流

- 前端限流（通过按钮控制）
- 后端限流

阿里的Sentinel和Hystrix限流组件



### 库存预热

- 把商品的库存加载到redis中去
- 在redis中做秒杀
- 后续更新数据库

**但是存在问题：**

由于使用了主从结构，但可能存在超卖



**解决方案：**

Lua脚本支持原子操作



### 限流&降级&熔断&隔离



### 削峰填谷



## 结构图

其中主要的就两块：

- redis负责快速响应用户请求（不超卖）
- 消息队列负责血风田谷，维持数据库稳定

防止当订单量过大，频繁修改导致数据库崩溃

![16e72d24415cb009~tplv-t2oaga2asx-zoom-in-crop-mark_4536_0_0_0](D:\workstation\就业方向\实习\java八股\javaWhite\系统设计\pic\16e72d24415cb009~tplv-t2oaga2asx-zoom-in-crop-mark_4536_0_0_0.webp)

**redis读写分离做库存扣减**

- 读请求到达slave节点，如果已经0了，则直接返回
- 如果库存有剩余，则到达master节点
- 在master节点上执行Lua脚本的cas操作，防止超卖



## 关键问题

- Redis的并发竞争问题
- Redis的数据同步方式

以上参考Redis篇

- MQ的作用
  - 异步
  - 削峰
  - 解耦

以上参考MQ篇



# 设计秒杀系统-2



参考：[面试必考：秒杀系统要如何设计？ - 掘金 (juejin.cn)](https://juejin.cn/post/6990307911117307934)

**非常经典的读多写少：所有人多会读，但只有少部分人能够写**



## 缓存问题

### 缓存击穿

一开始参与秒杀的商品并不在缓存中，所有请求打到数据库上；

**解决方法：**

- 预热，把参与秒杀的商品事先加入到缓存中
- 加分布式锁，只有获取锁的请求才能访问数据库，其余直接返回失败，下一次请求时缓存中已经有数据了

加锁的作用是，只需要少数人访问数据库，后续的请求可以走缓存。



### 缓存穿透

在缓存和数据库中都不存在

**解决办法：**

- 布隆过滤器，布谷鸟过滤器：缓存更新很少的场景
- 不存在的商品id也存在缓存中



## 库存问题

需要考虑：预扣库存，回退库存，库存不足和库存超卖

### 数据库读者扣减库存

必须使用以下句子，即满足原子性：

```sql
update product set stock=stock-1 where id=product and stock > 0;
```

数据库性能不佳



### Redis扣减库存

#### 先查再减

同时大量的请求判断>1，存在超卖问题

#### 先减再查

根据减后的结果判断是否成功

==与上述的区别在于这个是原子操作==



### Lua 扣减库存

由此可见，希望能在redis上实现原子操作的扣减



## 谈谈分布式锁

### setNx

非原子

### set

原子

### 自旋锁

在高并发的场景下，悲观锁性能很差，因此使用自旋锁

基于悲观锁实现：

- 规定时间内不断自旋
- 成功退出
- 失败则休眠一段时间
- 继续抢锁，直到超过最大时间范围











